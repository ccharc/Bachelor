dim(XTX)
#L_R <- chol(XTX)
#L_custom <- cholesky(XTX)
data("cars")
head(cars)
mod1 <- lm(dist~speed, cars)
plot(dist~speed, cars)
beta_hat1 <- coef(mod1)
abline(beta_hat1)
?matrix
matrix(cars$speed)
matrix(numeric(1), nrow = 50, ncol = 2)
matrix(1, nrow = 50, ncol = 2)
[,2] <- cars$speed
m_1[,2] <- cars$speed
m_1 <- matrix(1, nrow = 50, ncol = 2)
m_1[,2] <- cars$speed
m_1
?backsolve
m_2 <- cars$dist
m_2 <- c(cars$dist)
m_2
m_2 <- matrix(cars$dist, nrow = 50, ncol = 1)
m_2
x_vec <- c(x_1, x_2)
knitr::opts_chunk$set(echo = TRUE)
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# TODO: Implement
return(x_k)
}
MinimizeCG52 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# TODO: Implement
return(x_k)
}
# "Software for Data Analysis"
# install.packages("SoDA")
library(SoDA)
install.packages(soda)
install.packages("SoDA")
install.packages("matrixcalc")
knitr::opts_chunk$set(echo = TRUE)
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# TODO: Implement
return(x_k)
}
MinimizeCG52 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# TODO: Implement
return(x_k)
}
# "Software for Data Analysis"
# install.packages("SoDA")
library(SoDA)
N <- 500 # problem dimension
A <- triDiag(diagonal = 2, upper = -1, lower = -1, nrow = N)
A[1:10, 1:10]
str(A)
# install.packages("matrixcalc")
library(matrixcalc)
isSymmetricPD <- is.positive.definite(A)
cat("det(A) =", det(A), ";\t SPD = ", isSymmetricPD, "\n")
x_true <- rep(1, N)
b <- A %*% x_true
solve_error_term <- norm(solve(A, b) - x_true)
solve_error_term
norm_r_tol <- solve_error_term
x_0 <- rep(0, N)
timing_result_51 <- system.time({ x_min_51 = MinimizeCG51(x_k = x_0, A, b) })
error_term_51 <- x_min_51 - x_true
cat("A5.1: ||x_k - x*|| =", norm(error_term_51, type = "2"), "\n")
timing_result_51
timing_result_52 <- system.time({ x_min_52 = MinimizeCG52(x_k = x_0, A, b) })
error_term_52 <- x_min_52 - x_true
cat("A5.2: ||x_k - x*|| =", norm(error_term_52, type = "2"), "\n")
timing_result_52
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
Given x_0;
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_(k+1) <- x_k + alpha_k * p_k;
r_(k+1) <- A %*% x_(k+1) - b;
beta_(k+1) <- (t(r_(k+1)) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_(k+1) <- - r-(k+1) + beta_(k+1) * p_k
k <- k+1
}
return(x_k)
}
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0 & k < k_max){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_(k+1) <- x_k + alpha_k * p_k;
r_(k+1) <- A %*% x_(k+1) - b;
beta_(k+1) <- (t(r_(k+1)) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_(k+1) <- - r-(k+1) + beta_(k+1) * p_k
k <- k+1
}
return(x_k)
}
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0 & k < k_max){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_(k+1) <- x_k + alpha_k * p_k;
r_(k+1) <- A %*% x_(k+1) - b;
beta_(k+1) <- (t(r_(k+1)) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_(k+1) <- - r_(k+1) + beta_(k+1) * p_k
k <- k+1
}
return(x_k)
}
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0 & k < k_max){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_k <- x_k + alpha_k * p_k;
r_k <- A %*% x_k - b;
beta_k <- (t(r_k) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_k <- - r_k + beta_k * p_k
k <- k+1
}
return(x_k)
}
knitr::opts_chunk$set(echo = TRUE)
library(SoDA)
N <- 500 # problem dimension
A <- triDiag(diagonal = 2, upper = -1, lower = -1, nrow = N)
# condition number
# https://en.wikipedia.org/wiki/Condition_number#Matrices
kappa(A)
knitr::opts_chunk$set(echo = TRUE)
library("animation")
Outer <- function(x,y,fun) {
mat <- matrix(NA, length(x), length(y))
for (i in seq_along(x)) {
for (j in seq_along(y)) {mat[i,j] <- fun(x[i],y[j])} }
mat}
printf <- function(...) cat(sprintf(...))
printfln <- function(...) cat(sprintf(...), "\n")
plot(dist ~ speed, cars)
f <- function(ab){
sum = 0
n <- length(cars$dist)
s <- cars$speed
d <- cars$dist
return(1/n * sum((ab[1] + ab[2] * s - d)^2))
}
f_xy <- function(x,y) return(f(c(x,y)))
g <- function(ab){
n <- length(cars$speed)
s <- cars$speed
d <- cars$dist
g_a <- 1/n * sum(2 * (ab[1] + ab[2] * s - d) )
g_b <- 1/n * sum(2 * (ab[1] + ab[2] * s - d) * s)
return(c(g_a,g_b))
}
backtracking_line_search <- function(alpha, c, rho, x_k, p_k, g_k, f) {
alpha_k <- alpha
repeat {
lhs <- f(x_k + alpha_k * p_k)
rhs <- f(x_k) + c * alpha_k * g_k %*% p_k
if (lhs <= rhs) break
alpha_k <- rho * alpha_k
}
return(alpha_k)
}
steepest_descent <- function(f, g, x_k, alpha, c, rho, tol, k_max) {
N <- 30
x <- seq(-20,3,length=N)
y <- seq(1,7,  length=N)
z <- Outer(x , y , f_xy)
lev <- c(300,500,750,1000,2000,4000)
contour(x, y, z, levels = lev)
k <- 0
g_k <- tol + 1 # For at komme i gang
while ((norm(g_k , type="2") > tol) & (k < k_max)) { # Type 2 er for vektorer
g_k <- g(x_k)
p_k <- -g_k
alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
x_old <- x_k
x_k <- x_k + alpha_k * p_k
k <- k + 1
lines(c(x_old[1],x_k[1]) , c(x_old[2],x_k[2]) , col = "red")
}
printfln("k = %d \t x_k = (%6.3f , %6.3f) \t f_k = %.2f \t g_k = (%8.3f , %8.3f) \t alpha_k = %.5f", k, x_k[1] , x_k[2], f(x_k), g_k[1] , g_k[2], alpha_k)
return(x_k)
}
x_sol <- steepest_descent(f, g, x_k   = c(1,5) ,
alpha = 1      ,
c     = 1e-4   ,
rho   = 0.5    ,
tol   = 1e-4   ,
k_max = 20000)
plot(dist ~ speed , cars)
abline(x_sol , col = "red")
legend(4,115,legend = "m(s) = a + bs" , col = "red" , lty = 1)
f_xy <- function(x,y) return(f(c(x,y)))
f <- function(ab){
sum = 0
n <- length(cars$dist)
s <- cars$speed
d <- cars$dist
return(1/n * sum((ab[1] + ab[2] * s - d)^2))
}
f_xy <- function(x,y) return(f(c(x,y)))
clear
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
install.packages("magrittr")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages("imager")
#Load the image
img <- load.image("candy.jpg")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
#Load the image
img <- load.image("candy.jpg")
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library("imager")
#Load the image
img <- load.image("candy.jpg")
detach("package:imager", unload=TRUE)
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
remove.packages("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
rm(list=ls())   #Delete old variables
graphics.off()  #Delete old plots
library("imager")
remove.packages("imager")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages(c("animation", "backports", "class", "codetools", "digest", "evaluate", "foreign", "jsonlite", "knitr", "lattice", "markdown", "MASS", "Matrix", "mgcv", "microbenchmark", "mime", "Rcpp", "rmarkdown", "Rmpfr", "stringi", "stringr", "survival", "tinytex", "xfun"))
library("imager")
install.packages("magrittr")
library("imager")
library("animation")
detach("package:animation", unload=TRUE)
install.packages("imager")
library("imager")
rm(list=ls())
graphics.off()
set.seed(2)
x=matrix(rnorm (50*2), ncol=2)
x[1:25,1]=x[1:25,1]+3
x[1:25,2]=x[1:25,2]-4
num = 1:50
hc.complete =hclust(dist(x), method="complete")
clust = cutree(hc.complete , 2)
par(mfrow = c(1,2))
par(mar=c(2,2,2,2))
plot(x , main="Data", xlab="", ylab="", type='n', xaxt='n',yaxt='n')
text(x[,1],x[,2],col=clust,labels =as.character(num), cex=0.4)
plot(hc.complete ,main="Complete Linkage", xlab="", ylab="",sub="", cex=.4, hang=-1)
data("iris")
kmeans(K=3, N=10)
?kmeans
kmeans(x, K=3, N=10)
kmeans(x,3,10)
load(iris)
?tail
head(iris)
(73.89-72.37)/72.37 *100
(94,49-71,86)/71.86*100
(94.49-71.86)/71.86*100
(91.88-71.86)/71.86*100
(91.31-71.86)/71.86*100
(101.54-71.86)/71.86*100
(73.75-71.86)/71.86*100
residuals.lm(dk1p)
residuals.lm(arima(dk1p))
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
plot(y)
acf(y)
diff(y)
x=diff(y)
acf(x)
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
plot(vartime())
plot(vartime(10))
plot(vartime())
adf?
?adf
clc
cleart
clear
?adf
adf.test?
adf.test
?adf.test
library(readxl)
library(vars)
library(imputeTS)
library(forecast)
library(tseries)
library(stats)
library(strucchange)
library(tidyr)
#elprice15 = data.frame(read.csv("elspot-prices_2015_hourly_eur.csv",sep=";"))
elprice16 =  data.frame(read.csv("elspot-prices_2016_hourly_eur.csv",sep=";",dec=","))
#elprice17 = data.frame(read.csv("elspot-prices_2017_hourly_eur.csv",sep=";"))
#elprice18 = data.frame(read.csv("elspot-prices_2018_hourly_eur.csv",sep=";"))
#cons15 = data.frame(read.csv("consumption-se-areas_2015_hourly.csv",sep=";"))
cons16 = data.frame(read.csv("consumption-se-areas_2016_hourly.csv",sep=";"))
#cons17 = data.frame(read.csv("consumption-se-areas_2017_hourly.csv",sep=";"))
#cons18 = data.frame(read.csv("consumption-se-areas_2018_hourly.csv",sep=";"))
#wind15 = data.frame(read.csv("wind-power-se_2015_hourly.csv",sep=";"))
wind16 = data.frame(read.csv("wind-power-se_2016_hourly.csv",sep=";"))
#wind17 = data.frame(read.csv("wind-power-se_2017_hourly.csv",sep=";"))
#wind18 = data.frame(read.csv("wind-power-se_2018_hourly.csv",sep=";"))
#PRISER
#PRICE15 = elprice15[554:8763,4]
PRICE16 = elprice16[1:8784,5]
#PRICE17 = elprice17[3:8763,4]
#PRICE18 = elprice18[3:6290,4]
SE2price = data.frame(na.approx(c(PRICE16)))
#FORBRUG
#CONS15 = cons15[554:8763,3]
CONS16 = cons16[3:8786,4]
#CONS17 = cons17[3:8763,3]
#CONS18 = cons18[3:6290,3]
SE2cons = data.frame(na_interpolation(c(CONS16), option = "linear"))
#VINDPRODUKTION
#WIND15 = wind15[554:8763,3]
WIND16 = wind16[3:8786,4]
#WIND17 = wind17[3:8763,3]
#WIND18 = wind18[3:6290,3]
SE2wind = data.frame(na_interpolation(c(WIND16), option = "linear"))
#DATO
dato1 <- seq(c(ISOdate(2016,1,1,0)), by = "hours", length.out = 8784)
#DATA
data = data.frame(dato1,SE2price,SE2cons,SE2wind)
plot.ts(PRICE16)
plot.ts(CONS16)
plot.ts(WIND16)
setwd("~/Desktop/MatØk6/Bachelor")
library(readxl)
library(vars)
library(imputeTS)
library(forecast)
library(tseries)
library(stats)
library(strucchange)
library(tidyr)
#elprice15 = data.frame(read.csv("elspot-prices_2015_hourly_eur.csv",sep=";"))
elprice16 =  data.frame(read.csv("elspot-prices_2016_hourly_eur.csv",sep=";",dec=","))
#elprice17 = data.frame(read.csv("elspot-prices_2017_hourly_eur.csv",sep=";"))
#elprice18 = data.frame(read.csv("elspot-prices_2018_hourly_eur.csv",sep=";"))
#cons15 = data.frame(read.csv("consumption-se-areas_2015_hourly.csv",sep=";"))
cons16 = data.frame(read.csv("consumption-se-areas_2016_hourly.csv",sep=";"))
#cons17 = data.frame(read.csv("consumption-se-areas_2017_hourly.csv",sep=";"))
#cons18 = data.frame(read.csv("consumption-se-areas_2018_hourly.csv",sep=";"))
#wind15 = data.frame(read.csv("wind-power-se_2015_hourly.csv",sep=";"))
wind16 = data.frame(read.csv("wind-power-se_2016_hourly.csv",sep=";"))
#wind17 = data.frame(read.csv("wind-power-se_2017_hourly.csv",sep=";"))
#wind18 = data.frame(read.csv("wind-power-se_2018_hourly.csv",sep=";"))
#PRISER
#PRICE15 = elprice15[554:8763,4]
PRICE16 = elprice16[1:8784,5]
#PRICE17 = elprice17[3:8763,4]
#PRICE18 = elprice18[3:6290,4]
SE2price = data.frame(na.approx(c(PRICE16)))
#FORBRUG
#CONS15 = cons15[554:8763,3]
CONS16 = cons16[3:8786,4]
#CONS17 = cons17[3:8763,3]
#CONS18 = cons18[3:6290,3]
SE2cons = data.frame(na_interpolation(c(CONS16), option = "linear"))
#VINDPRODUKTION
#WIND15 = wind15[554:8763,3]
WIND16 = wind16[3:8786,4]
#WIND17 = wind17[3:8763,3]
#WIND18 = wind18[3:6290,3]
SE2wind = data.frame(na_interpolation(c(WIND16), option = "linear"))
#DATO
dato1 <- seq(c(ISOdate(2016,1,1,0)), by = "hours", length.out = 8784)
#DATA
data = data.frame(dato1,SE2price,SE2cons,SE2wind)
plot.ts(PRICE16)
plot.ts(CONS16)
plot.ts(WIND16)
### SARMA
### Sæson kvartal price
se2pricekvart1 = data[1:2182,1:2]
se2pricekvart2 = data[2183:4366,1:2]
se2pricekvart3 = data[4367:6574,1:2]
se2pricekvart4 = data[6575:8784,1:2]
### Sæson kvartal cons
se2conskvart1 = data[1:2182,c(1,3)]
se2conskvart2 = data[2183:4366,c(1,3)]
se2conskvart3 = data[4367:6574,c(1,3)]
se2conskvart4 = data[6575:8784,c(1,3)]
### Sæson kvartal wind
se2windkvart1 = data[1:2182,c(1,4)]
se2windkvart2 = data[2183:4366,c(1,4)]
se2windkvart3 = data[4367:6574,c(1,4)]
se2windkvart4 = data[6575:8784,c(1,4)]
swindkvart1 = glm(se2windkvart1[,2] ~ time(se2windkvart1[,1]) +
I(time(se2windkvart1[,1])^2) +
sin((8*pi)/8784*I(time(se2windkvart1[,1])))+
cos((8*pi)/8784*I(time(se2windkvart1[,1])))+
sin((24*pi)/8784*I(time(se2windkvart1[,1])))+
cos((24*pi)/8784*I(time(se2windkvart1[,1])))+
sin((104*pi)/8784*I(time(se2windkvart1[,1])))+
cos((104*pi)/8784*I(time(se2windkvart1[,1])))+
sin((732*pi)/8784*I(time(se2windkvart1[,1])))+
cos((732*pi)/8784*I(time(se2windkvart1[,1])))+
sin((17570*pi)/8784*I(time(se2windkvart1[,1])))+
cos((17570*pi)/8784*I(time(se2windkvart1[,1])))
)
sconskvart1 = glm(se2conskvart1[,2] ~ time(se2conskvart1[,1]) +
I(time(se2conskvart1[,1])^2) +
sin((8*pi)/8784*I(time(se2conskvart1[,1])))+
cos((8*pi)/8784*I(time(se2conskvart1[,1])))+
sin((24*pi)/8784*I(time(se2conskvart1[,1])))+
cos((24*pi)/8784*I(time(se2conskvart1[,1])))+
sin((104*pi)/8784*I(time(se2conskvart1[,1])))+
cos((104*pi)/8784*I(time(se2conskvart1[,1])))+
sin((732*pi)/8784*I(time(se2conskvart1[,1])))+
cos((732*pi)/8784*I(time(se2conskvart1[,1])))+
sin((17570*pi)/8784*I(time(se2conskvart1[,1])))+
cos((17570*pi)/8784*I(time(se2conskvart1[,1])))
)
spricekvart1 = glm(se2pricekvart1[,2] ~ time(se2pricekvart1[,1]) +
I(time(se2pricekvart1[,1])^2) +
sin((8*pi)/8784*I(time(se2pricekvart1[,1])))+
cos((8*pi)/8784*I(time(se2pricekvart1[,1])))+
sin((24*pi)/8784*I(time(se2pricekvart1[,1])))+
cos((24*pi)/8784*I(time(se2pricekvart1[,1])))+
sin((104*pi)/8784*I(time(se2pricekvart1[,1])))+
cos((104*pi)/8784*I(time(se2pricekvart1[,1])))+
sin((732*pi)/8784*I(time(se2pricekvart1[,1])))+
cos((732*pi)/8784*I(time(se2pricekvart1[,1])))+
sin((17570*pi)/8784*I(time(se2pricekvart1[,1])))+
cos((17570*pi)/8784*I(time(se2pricekvart1[,1])))
)
# WIND
x_t1 = ts(swindkvart1$residuals)
x_t2 = ts(swindkvart2$residuals)
x_t3 = ts(swindkvart3$residuals)
x_t4 = ts(swindkvart4$residuals)
#CONS
z_t1 = ts(sconskvart1$residuals)
z_t2 = ts(sconskvart2$residuals)
z_t3 = ts(sconskvart3$residuals)
z_t4 = ts(sconskvart4$residuals)
# PRICE
y_t1 = ts(spricekvart1$residuals)
y_t2 = ts(spricekvart2$residuals)
y_t3 = ts(spricekvart3$residuals)
y_t4 = ts(spricekvart4$residuals)
acf(x_t1)
seas_x1 = auto.arima(x_t1, d=0, seasonal = TRUE)
res_x1 = ts(seas_x1$residuals)
seas_y1 = auto.arima(y_t1, d=0, seasonal = TRUE)
res_y1 = ts(seas_y1$residuals)
seas_z1 = auto.arima(z_t1, d=0, seasonal = TRUE)
res_z1 = ts(seas_z1$residuals)
seas_Xt = data.frame(res_y1, res_x1, res_z1)
seas_fit1 = VAR(seas_Xt, ic = "AIC", lag.max = 10)
summary(seas_fit1)
seas
seas_y1$season
