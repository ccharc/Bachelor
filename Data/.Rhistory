?function
:
?data
knitr::opts_chunk$set(echo = TRUE)
n <- 10L
m <- 100L
set.seed(1)
X <- matrix(rnorm(n * m), m, n)
XTX <- crossprod(X)
dim(XTX)
#L_R <- chol(XTX)
#L_custom <- cholesky(XTX)
data("cars")
head(cars)
lm(dist~speed, cars)
svd(dist~speed, cars)
knitr::opts_chunk$set(echo = TRUE)
n <- 10L
m <- 100L
set.seed(1)
X <- matrix(rnorm(n * m), m, n)
XTX <- crossprod(X)
dim(XTX)
#L_R <- chol(XTX)
#L_custom <- cholesky(XTX)
data("cars")
head(cars)
lm(dist~speed, cars)
svd(dist~speed, cars)
knitr::opts_chunk$set(echo = TRUE)
n <- 10L
m <- 100L
set.seed(1)
X <- matrix(rnorm(n * m), m, n)
XTX <- crossprod(X)
dim(XTX)
#L_R <- chol(XTX)
#L_custom <- cholesky(XTX)
data("cars")
head(cars)
lm(dist~speed, cars)
plot(dist~speed, cars)
knitr::opts_chunk$set(echo = TRUE)
n <- 10L
m <- 100L
set.seed(1)
X <- matrix(rnorm(n * m), m, n)
XTX <- crossprod(X)
dim(XTX)
#L_R <- chol(XTX)
#L_custom <- cholesky(XTX)
data("cars")
head(cars)
mod1 <- lm(dist~speed, cars)
plot(dist~speed, cars)
beta_hat1 <- coef(mod1)
abline(beta_hat1)
?matrix
matrix(cars$speed)
matrix(numeric(1), nrow = 50, ncol = 2)
matrix(1, nrow = 50, ncol = 2)
[,2] <- cars$speed
m_1[,2] <- cars$speed
m_1 <- matrix(1, nrow = 50, ncol = 2)
m_1[,2] <- cars$speed
m_1
?backsolve
m_2 <- cars$dist
m_2 <- c(cars$dist)
m_2
m_2 <- matrix(cars$dist, nrow = 50, ncol = 1)
m_2
x_vec <- c(x_1, x_2)
knitr::opts_chunk$set(echo = TRUE)
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# TODO: Implement
return(x_k)
}
MinimizeCG52 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# TODO: Implement
return(x_k)
}
# "Software for Data Analysis"
# install.packages("SoDA")
library(SoDA)
install.packages(soda)
install.packages("SoDA")
install.packages("matrixcalc")
knitr::opts_chunk$set(echo = TRUE)
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# TODO: Implement
return(x_k)
}
MinimizeCG52 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# TODO: Implement
return(x_k)
}
# "Software for Data Analysis"
# install.packages("SoDA")
library(SoDA)
N <- 500 # problem dimension
A <- triDiag(diagonal = 2, upper = -1, lower = -1, nrow = N)
A[1:10, 1:10]
str(A)
# install.packages("matrixcalc")
library(matrixcalc)
isSymmetricPD <- is.positive.definite(A)
cat("det(A) =", det(A), ";\t SPD = ", isSymmetricPD, "\n")
x_true <- rep(1, N)
b <- A %*% x_true
solve_error_term <- norm(solve(A, b) - x_true)
solve_error_term
norm_r_tol <- solve_error_term
x_0 <- rep(0, N)
timing_result_51 <- system.time({ x_min_51 = MinimizeCG51(x_k = x_0, A, b) })
error_term_51 <- x_min_51 - x_true
cat("A5.1: ||x_k - x*|| =", norm(error_term_51, type = "2"), "\n")
timing_result_51
timing_result_52 <- system.time({ x_min_52 = MinimizeCG52(x_k = x_0, A, b) })
error_term_52 <- x_min_52 - x_true
cat("A5.2: ||x_k - x*|| =", norm(error_term_52, type = "2"), "\n")
timing_result_52
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
Given x_0;
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_(k+1) <- x_k + alpha_k * p_k;
r_(k+1) <- A %*% x_(k+1) - b;
beta_(k+1) <- (t(r_(k+1)) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_(k+1) <- - r-(k+1) + beta_(k+1) * p_k
k <- k+1
}
return(x_k)
}
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0 & k < k_max){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_(k+1) <- x_k + alpha_k * p_k;
r_(k+1) <- A %*% x_(k+1) - b;
beta_(k+1) <- (t(r_(k+1)) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_(k+1) <- - r-(k+1) + beta_(k+1) * p_k
k <- k+1
}
return(x_k)
}
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0 & k < k_max){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_(k+1) <- x_k + alpha_k * p_k;
r_(k+1) <- A %*% x_(k+1) - b;
beta_(k+1) <- (t(r_(k+1)) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_(k+1) <- - r_(k+1) + beta_(k+1) * p_k
k <- k+1
}
return(x_k)
}
MinimizeCG51 <- function(x_k, A, b, k_max = 1000, tolerance = sqrt(.Machine$double.eps)) {
# Given x_0;
r_k <- Ax_k - b; p_k <- -r_k; k <- 0
while(r_k != 0 & k < k_max){
alpha_k <- - (t(r_k) * p_k)/(t(p_k) %*% A %*% p_k);
x_k <- x_k + alpha_k * p_k;
r_k <- A %*% x_k - b;
beta_k <- (t(r_k) %*% A %*% p_k)/ (t(p_k) %*% A %*% p_k);
p_k <- - r_k + beta_k * p_k
k <- k+1
}
return(x_k)
}
knitr::opts_chunk$set(echo = TRUE)
library(SoDA)
N <- 500 # problem dimension
A <- triDiag(diagonal = 2, upper = -1, lower = -1, nrow = N)
# condition number
# https://en.wikipedia.org/wiki/Condition_number#Matrices
kappa(A)
knitr::opts_chunk$set(echo = TRUE)
library("animation")
Outer <- function(x,y,fun) {
mat <- matrix(NA, length(x), length(y))
for (i in seq_along(x)) {
for (j in seq_along(y)) {mat[i,j] <- fun(x[i],y[j])} }
mat}
printf <- function(...) cat(sprintf(...))
printfln <- function(...) cat(sprintf(...), "\n")
plot(dist ~ speed, cars)
f <- function(ab){
sum = 0
n <- length(cars$dist)
s <- cars$speed
d <- cars$dist
return(1/n * sum((ab[1] + ab[2] * s - d)^2))
}
f_xy <- function(x,y) return(f(c(x,y)))
g <- function(ab){
n <- length(cars$speed)
s <- cars$speed
d <- cars$dist
g_a <- 1/n * sum(2 * (ab[1] + ab[2] * s - d) )
g_b <- 1/n * sum(2 * (ab[1] + ab[2] * s - d) * s)
return(c(g_a,g_b))
}
backtracking_line_search <- function(alpha, c, rho, x_k, p_k, g_k, f) {
alpha_k <- alpha
repeat {
lhs <- f(x_k + alpha_k * p_k)
rhs <- f(x_k) + c * alpha_k * g_k %*% p_k
if (lhs <= rhs) break
alpha_k <- rho * alpha_k
}
return(alpha_k)
}
steepest_descent <- function(f, g, x_k, alpha, c, rho, tol, k_max) {
N <- 30
x <- seq(-20,3,length=N)
y <- seq(1,7,  length=N)
z <- Outer(x , y , f_xy)
lev <- c(300,500,750,1000,2000,4000)
contour(x, y, z, levels = lev)
k <- 0
g_k <- tol + 1 # For at komme i gang
while ((norm(g_k , type="2") > tol) & (k < k_max)) { # Type 2 er for vektorer
g_k <- g(x_k)
p_k <- -g_k
alpha_k <- backtracking_line_search(alpha, c, rho, x_k, p_k, g_k, f)
x_old <- x_k
x_k <- x_k + alpha_k * p_k
k <- k + 1
lines(c(x_old[1],x_k[1]) , c(x_old[2],x_k[2]) , col = "red")
}
printfln("k = %d \t x_k = (%6.3f , %6.3f) \t f_k = %.2f \t g_k = (%8.3f , %8.3f) \t alpha_k = %.5f", k, x_k[1] , x_k[2], f(x_k), g_k[1] , g_k[2], alpha_k)
return(x_k)
}
x_sol <- steepest_descent(f, g, x_k   = c(1,5) ,
alpha = 1      ,
c     = 1e-4   ,
rho   = 0.5    ,
tol   = 1e-4   ,
k_max = 20000)
plot(dist ~ speed , cars)
abline(x_sol , col = "red")
legend(4,115,legend = "m(s) = a + bs" , col = "red" , lty = 1)
f_xy <- function(x,y) return(f(c(x,y)))
f <- function(ab){
sum = 0
n <- length(cars$dist)
s <- cars$speed
d <- cars$dist
return(1/n * sum((ab[1] + ab[2] * s - d)^2))
}
f_xy <- function(x,y) return(f(c(x,y)))
clear
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
install.packages("magrittr")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages("imager")
#Load the image
img <- load.image("candy.jpg")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
#Load the image
img <- load.image("candy.jpg")
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
library("imager")
#Load the image
img <- load.image("candy.jpg")
detach("package:imager", unload=TRUE)
library("imager", lib.loc="/Library/Frameworks/R.framework/Versions/3.5/Resources/library")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
remove.packages("imager")
#Library to load images into R.
#You my have to install it first ---> installer.packages("imager)
install.packages("imager")
library("imager")
rm(list=ls())   #Delete old variables
graphics.off()  #Delete old plots
library("imager")
remove.packages("imager")
install.packages("imager")
library("imager")
install.packages("imager")
install.packages(c("animation", "backports", "class", "codetools", "digest", "evaluate", "foreign", "jsonlite", "knitr", "lattice", "markdown", "MASS", "Matrix", "mgcv", "microbenchmark", "mime", "Rcpp", "rmarkdown", "Rmpfr", "stringi", "stringr", "survival", "tinytex", "xfun"))
library("imager")
install.packages("magrittr")
library("imager")
library("animation")
detach("package:animation", unload=TRUE)
install.packages("imager")
library("imager")
rm(list=ls())
graphics.off()
set.seed(2)
x=matrix(rnorm (50*2), ncol=2)
x[1:25,1]=x[1:25,1]+3
x[1:25,2]=x[1:25,2]-4
num = 1:50
hc.complete =hclust(dist(x), method="complete")
clust = cutree(hc.complete , 2)
par(mfrow = c(1,2))
par(mar=c(2,2,2,2))
plot(x , main="Data", xlab="", ylab="", type='n', xaxt='n',yaxt='n')
text(x[,1],x[,2],col=clust,labels =as.character(num), cex=0.4)
plot(hc.complete ,main="Complete Linkage", xlab="", ylab="",sub="", cex=.4, hang=-1)
data("iris")
kmeans(K=3, N=10)
?kmeans
kmeans(x, K=3, N=10)
kmeans(x,3,10)
load(iris)
?tail
head(iris)
(73.89-72.37)/72.37 *100
(94,49-71,86)/71.86*100
(94.49-71.86)/71.86*100
(91.88-71.86)/71.86*100
(91.31-71.86)/71.86*100
(101.54-71.86)/71.86*100
(73.75-71.86)/71.86*100
residuals.lm(dk1p)
residuals.lm(arima(dk1p))
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
y <- arima.sim(model=list(ma=0.3, order =c(0,0,1)), n=10000)
plot(y)
acf(y)
diff(y)
x=diff(y)
acf(x)
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
vartime = function(x, nmax = round(length(x) / 10)) {
v = rep(NA, nmax);
for (n in 1:nmax) {
y = filter(x, rep(1/n, n), sides = 1);
v[n] = var(y, na.rm = TRUE);
}
plot(log(1:nmax), log(v));
lmv = lm(log(v) ~ log(1:nmax));
abline(lmv);
title(paste(deparse(substitute(x)), "; nmax = ", nmax));
print(summary(lmv));
}
vartime(log(varve))
vartime(residuals(lm(log(varve) ~ time(log(varve)))))
plot(vartime())
plot(vartime(10))
plot(vartime())
adf?
?adf
clc
cleart
clear
?adf
adf.test?
adf.test
?adf.test
setwd("~/Desktop/MatØk6/Bachelor/Data")
mod1 = lm(SE1price ~ SE1cons)
elprice15 = read_xls("elspot-prices_2015_hourly_eur.xls")
elprice16 = read_xls("elspot-prices_2016_hourly_eur.xls")
elprice17 = read_xls("elspot-prices_2017_hourly_eur.xls")
elprice18 = read_xls("elspot-prices_2018_hourly_eur.xls")
cons15 = read_xls("consumption-se-areas_2015_hourly.xls")
cons16 = read_xls("consumption-se-areas_2016_hourly.xls")
cons17 = read_xls("consumption-se-areas_2017_hourly.xls")
cons18 = read_xls("consumption-se-areas_2018_hourly.xls")
wind15 = read_xls("wind-power-se_2015_hourly.xls")
wind16 = read_xls("wind-power-se_2016_hourly.xls")
wind17 = read_xls("wind-power-se_2017_hourly.xls")
wind18 = read_xls("wind-power-se_2018_hourly.xls")
library(readxl)
elprice15 = read_xls("elspot-prices_2015_hourly_eur.xls")
elprice16 = read_xls("elspot-prices_2016_hourly_eur.xls")
elprice17 = read_xls("elspot-prices_2017_hourly_eur.xls")
elprice18 = read_xls("elspot-prices_2018_hourly_eur.xls")
cons15 = read_xls("consumption-se-areas_2015_hourly.xls")
cons16 = read_xls("consumption-se-areas_2016_hourly.xls")
cons17 = read_xls("consumption-se-areas_2017_hourly.xls")
cons18 = read_xls("consumption-se-areas_2018_hourly.xls")
wind15 = read_xls("wind-power-se_2015_hourly.xls")
wind16 = read_xls("wind-power-se_2016_hourly.xls")
wind17 = read_xls("wind-power-se_2017_hourly.xls")
wind18 = read_xls("wind-power-se_2018_hourly.xls")
dfp15 = data.frame(elprice15)
dfp16 = data.frame(elprice16)
dfp17 = data.frame(elprice17)
dfp18 = data.frame(elprice18)
PRICE15 = dfp15[747:8763,4]
PRICE16 = dfp16[3:8787,4]
PRICE17 = dfp17[3:8763,4]
PRICE18 = dfp18[3:8763,4]
SE1price= c(PRICE15,PRICE16,PRICE17,PRICE18)
#FORBRUG
dfc15 = data.frame(cons15)
dfc16 = data.frame(cons16)
dfc17 = data.frame(cons17)
dfc18 = data.frame(cons18)
CONS15 = dfc15[747:8763,3]
CONS16 = dfc16[3:8787,3]
CONS17 = dfc17[3:8763,3]
CONS18 = dfc18[3:8763,3]
SE1cons = c(CONS15,CONS16,CONS17,CONS18)
#VINDPRODUKTION
dfw15 = data.frame(wind15)
dfw16 = data.frame(wind16)
dfw17 = data.frame(wind17)
dfw18 = data.frame(wind18)
WIND15 = dfw15[747:8763,3]
WIND16 = dfw16[3:8787,3]
WIND17 = dfw17[3:8763,3]
WIND18 = dfw18[3:8763,3]
SE1wind = c(WIND15,WIND16,WIND17,WIND18)
#DATA
data = data.frame(SE1price,SE1cons,SE1wind)
windseries = ts(SE1wind)
consseries = ts(SE1cons)
priceseries= ts(SE1price)
plot.ts(priceseries)
mod1 = lm(SE1price ~ SE1cons)
summary(mod1)
install.packages("vars")
library(vars)
library(vars)
var(SE1price~SE1wind)
mod1=var(SE1price~SE1wind)
mod1 = var(SE1price ~ SE1cons, SE1wind)
mod1 = var(SE1price ~ SE1cons, SE1wind, is.atomic(SE1cons)=TRUE)
mod1 = var(SE1price ~ SE1cons, SE1wind, is.atomic(SE1cons) = TRUE)
mod1 = var(SE1price ~ SE1cons, SE1wind)
WIND15 = c(dfw15[747:8763,3])
View(WIND15)
WIND15
WIND16
dfp15 = data.frame(elprice15)
dfp16 = data.frame(elprice16)
dfp17 = data.frame(elprice17)
dfp18 = data.frame(elprice18)
PRICE15 = c(dfp15[747:8763,4])
PRICE16 = c(dfp16[3:8787,4])
PRICE17 = c(dfp17[3:8763,4])
PRICE18 = c(dfp18[3:8763,4])
SE1price= c(PRICE15,PRICE16,PRICE17,PRICE18)
#FORBRUG
dfc15 = data.frame(cons15)
dfc16 = data.frame(cons16)
dfc17 = data.frame(cons17)
dfc18 = data.frame(cons18)
CONS15 = c(dfc15[747:8763,3])
CONS16 = c(dfc16[3:8787,3])
CONS17 = c(dfc17[3:8763,3])
CONS18 = c(dfc18[3:8763,3])
SE1cons = c(CONS15,CONS16,CONS17,CONS18)
#VINDPRODUKTION
dfw15 = data.frame(wind15)
dfw16 = data.frame(wind16)
dfw17 = data.frame(wind17)
dfw18 = data.frame(wind18)
WIND15 = c(dfw15[747:8763,3])
WIND16 = c(dfw16[3:8787,3])
WIND17 = c(dfw17[3:8763,3])
WIND18 = c(dfw18[3:8763,3])
SE1wind = c(WIND15,WIND16,WIND17,WIND18)
#DATA
data = data.frame(SE1price,SE1cons,SE1wind)
windseries = ts(SE1wind)
consseries = ts(SE1cons)
priceseries= ts(SE1price)
plot.ts(priceseries)
library(vars)
mod1 = var(SE1price ~ SE1cons, SE1wind)
mod1 = var(SE1price ~ SE1cons, SE1wind)
mod1 = var(SE1price ~ SE1cons, SE1wind)
plot.ts(priceseries)
windseries = ts(SE1wind)
consseries = ts(SE1cons)
priceseries= ts(SE1price)
plot.ts(priceseries)
mean(priceseries)
mean(SE1price)
plot.ts(windseries)
plot.ts(consseries)
